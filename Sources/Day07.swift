import Algorithms

struct Day07: AdventDay {
  // Save your data in a corresponding text file in the `Data` directory.
  var data: String

  // --- Constants ---
  fileprivate static let startChar = "S"
  fileprivate static let emptyyChar = "."
  fileprivate static let splitterChar = "^"
  fileprivate static let beamChar = "|"

  /// Converts the input string into a TachyonManifold instance
  fileprivate var manifold: TachyonManifold {
    let matrix = data
      .trimmingCharacters(in: .whitespacesAndNewlines)
      .split(separator: "\n")
      .map { row in
        row.compactMap {
          CellType.fromString(String($0))
        }
      }
    
    return TachyonManifold(matrix: matrix)
  }

  // Solves the first part of the problem
  func part1() -> Any {
    var tachyonManifold = self.manifold

    tachyonManifold.simulate()

    return tachyonManifold.splitTimes
  }

  // Solves the second part of the problem
  func part2() -> Any {
    var tachyonManifold = self.manifold

    tachyonManifold.quantumSimulate()

    return tachyonManifold.timeLines
  }
}

/// A struct modeling the Tachyon Manifold
private struct TachyonManifold {
  /// A matrix of cells representing the entire manifold
  var matrix: [[CellType]]

  /// The number of times a beam has been split
  var splitTimes = 0

  /// The number of timelines created by the simulation
  var timeLines = 1

  /// Runs the simulation until the beam reaches the end,
  /// modifying the matrix in the process.
  /// Increments splitTimes each time a beam is split.
  mutating func simulate() -> Void {
    /// Number of rows to look at (each time we look
    /// at one row and the one below, so count - 2 avoids looking 
    /// below the last one)
    let depth = matrix.count - 2
    
    /// Start from level 1, because level 0 only has the starting point
    var currentLevel = 0

    repeat {
      // At each iteration, parse the current row's slots one by one,
      // looking at the slot above to decide how to update the current one
      let nextLevel = currentLevel + 1

      for i in 0 ..< matrix[currentLevel].count {
        switch matrix[currentLevel][i] {
          case .start, .beam :
            // A starting point generates a beam, and a beam generates another one below
            // Check what is below to decide what to do
            switch matrix[nextLevel][i] {
              case .splitter:
                // Split the beam into the bottom cell's neighbours,
                // UNLESS one of them is also a splitter
                let offsets = [-1, +1]
                for offset in offsets {
                  let offsetIndex = i + offset
                  if offsetIndex >= 0 && offsetIndex < matrix[nextLevel].count {
                    if matrix[nextLevel][offsetIndex] != .splitter {
                      matrix[nextLevel][offsetIndex] = .beam
                    }
                  }
                }

                // Increment the counter
                splitTimes += 1
              default: 
                // Continue the beam below this one
                matrix[nextLevel][i] = .beam
            }
          default: continue
        }
      }

      currentLevel += 1

    } while currentLevel <= depth

  }

  /// Runs the simulation using the Many-Worlds interpretation
  /// until all timelines have been explored.
  /// DOES NOT MODIFY THE MATRIX
  /// Stores in timelines the number of timelines that are generated by the simulation.
  mutating func quantumSimulate() {
    guard let startColumn = matrix.first?.firstIndex(of: .start) else {
      timeLines = 0
      return
    }
    
    let maxRow = matrix.count
    let maxCol = matrix.first!.count
    
    // Memoization table: nil = not yet computed
    var memo = Array(repeating: Array<Int?>(repeating: nil, count: maxCol), count: maxRow)
    
    // Function that implements a Depth-First Search.
    // We "look for" the bottom of the matrix with DFS.
    // Each time we reach the end of it, it means we have found a 
    // new unique path, so a timeline.
    // If along the way we find out that we have already been in this path,
    // we return the cached result instead of re-computating it.
    func dfs(row: Int, col: Int) -> Int {
      // Out of bounds or bottom of grid
      if row >= maxRow { return 1 }
      if col < 0 || col >= maxCol { return 0 }
      
      // Return cached result if available
      if let cached = memo[row][col] { return cached }
      
      let cell = matrix[row][col]
      let result: Int
      
      switch cell {
      case .splitter:
        // We can go either left or right, so we recursively run a DFS for each sub-branch
        result = dfs(row: row + 1, col: col - 1) + dfs(row: row + 1, col: col + 1)
      case .empty, .start, .beam:
        // We can only go down
        result = dfs(row: row + 1, col: col)
      }
      
      // Save the result to cache for later use
      memo[row][col] = result
      // Return the number of timelines found from the starting point
      return result
    }
    
    // Run the DFS algorithm starting from the beam's starting point
    timeLines = dfs(row: 0, col: startColumn)
  }
}

/// An enum of all possible slot components inside each cell 
/// of the Tachyon Manifold
private enum CellType: CaseIterable {
  case start
  case empty
  case splitter
  case beam

  /// Returns an instance of this enum matching the character, if it exists
  static func fromString(_ string: String) -> CellType? {
    for type in CellType.allCases {
      if type.string == string { return type }
    }

    return nil
  }

  /// The String representation of the cell type
  var string: String {
    switch self {
      case .start: Day07.startChar
      case  .empty: Day07.emptyyChar
      case .splitter: Day07.splitterChar
      case .beam: Day07.beamChar
    }
  }
}